<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaScript学习之路(五)面向对象程序设计 | Hao的博客空间</title><meta name="keywords" content="JavaScript,笔记"><meta name="author" content="Hao"><meta name="copyright" content="Hao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="理解对象 创建自定义对象最简单的方式就是创建一个Object的实例，再为实例添加属性和方法。 123456789101112131415161718&#x2F;&#x2F; 创建 Object 实例 person&#x2F;&#x2F; 第一种方式const person &#x3D; new Object();person.name &#x3D; &amp;#x27;zs&amp;#x27;person.age &#x3D; 18person.gender &#x3D; &amp;#x27;男&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习之路(五)面向对象程序设计">
<meta property="og:url" content="https://clh.lovehao.ren/2022/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%BA%94)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Hao的博客空间">
<meta property="og:description" content="理解对象 创建自定义对象最简单的方式就是创建一个Object的实例，再为实例添加属性和方法。 123456789101112131415161718&#x2F;&#x2F; 创建 Object 实例 person&#x2F;&#x2F; 第一种方式const person &#x3D; new Object();person.name &#x3D; &amp;#x27;zs&amp;#x27;person.age &#x3D; 18person.gender &#x3D; &amp;#x27;男&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://clh.lovehao.ren/img/article5.png">
<meta property="article:published_time" content="2022-03-28T06:34:07.000Z">
<meta property="article:modified_time" content="2022-03-31T08:57:06.547Z">
<meta property="article:author" content="Hao">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://clh.lovehao.ren/img/article5.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://clh.lovehao.ren/2022/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%BA%94)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript学习之路(五)面向对象程序设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-31 16:57:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article5.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hao的博客空间</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript学习之路(五)面向对象程序设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-28T06:34:07.000Z" title="发表于 2022-03-28 14:34:07">2022-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-31T08:57:06.547Z" title="更新于 2022-03-31 16:57:06">2022-03-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>理解对象</h1>
<p>创建自定义对象最简单的方式就是创建一个<code>Object</code>的实例，再为实例添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Object 实例 person</span></span><br><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">person.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">person.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="属性类型">属性类型</h2>
<p><code>ECMAScirpt</code> 中有两种属性类型： <code>数据属性类型</code> 和 <code>访问器属性</code></p>
<h3 id="数据属性">数据属性</h3>
<p>数据属性包含一个数值的位置。在这个位置可以读取和写入值。数据属性有<code>4</code>个描述其行为的特征：</p>
<ul>
<li><strong>[[Configurable]]</strong>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义属性，这个属性的默认值为 <code>true</code>。</li>
<li><strong>[[Enumerable]]</strong>：表示能否通过 for-in 循环返回属性。直接在对象上定义属性，这个属性的默认值为 <code>true</code>。</li>
<li><strong>[[Writable]]</strong>：表示能否修改属性的值。直接在对象上定义属性，这个属性的默认值为 <code>true</code>。</li>
<li><strong>[[Value]]</strong>：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性的时候，把新值保存在这个位置。这个属性的默认值为 <code>undefined</code> 。</li>
</ul>
<p>要修改属性默认的特性，必须使用 <code>ECMAScript 5</code> 的 <code>Object.defineProperty()</code> 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。描述符对象的属性必须是： <code>configurable</code> 、<code>enumerable</code>、 <code>writable</code> 和 <code>value</code>。设置其中的一个或多个值，可以修改对象的特性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// zs</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;ls&#x27;</span> <span class="comment">// writable 为 false 不可修改</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// zs</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;gender&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">gender</span>) <span class="comment">// 男</span></span><br><span class="line">person.<span class="property">gender</span> = <span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">gender</span>) <span class="comment">// 男</span></span><br></pre></td></tr></table></figure>
<h3 id="访问器属性">访问器属性</h3>
<p>访问器属性不包含数据值：它们包含一对 getter 和 setter 函数(不过这两个函数不是必须的)。在<strong>读取</strong>访问器属性时，会调用 getter 函数，这个函数负责返回有效的值，在<strong>写入</strong>访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。</p>
<p>访问器的4个特性：</p>
<ul>
<li><strong>[[Configurable]]</strong>：表示能否通过 delete 删除属性，从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义属性，这个属性的默认值为 <code>true</code>。</li>
<li><strong>[[Enumerable]]</strong>：表示能否通过 for-in 循环返回属性。直接在对象上定义属性，这个属性的默认值为 <code>true</code>。</li>
<li><strong>[[Get]]</strong>：在读取属性时调用的函数。默认值为 undefined。</li>
<li><strong>[[Set]]</strong>：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<p>访问器属性不能直接定义使用，必须使用 <code>Object.defineProperty()</code> 来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">_idcard</span>: <span class="number">123456789</span> <span class="comment">// _idcard 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;idcard&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_idcard</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = newValue - <span class="variable language_">this</span>.<span class="property">_idcard</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_idcard</span> = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.<span class="property">idcard</span> = <span class="number">123456791</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>访问器属性的常见作用是设置一个属性的值会导致其他属性发送变化。</p>
<blockquote>
<p>在<code> Object.defineProperty()</code> 方法之前，要创造访问器属性一般都使用两个非标准方法：<code>__defineGetter__()</code> 和 <code>__definedSetter__()</code>。</p>
</blockquote>
<h2 id="定义多个属性">定义多个属性</h2>
<p><code>ECMAScript 5</code> 中对象定义多个属性可以使用 <code>Objetc.denfineProperties()</code> 方法。利用这个方法可以通过描述符一次性定义多个属性。参数：第一个参数是需要修改对象，第二个需要的参数是第一个参数中需要添加或者修改的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义多个属性</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person, &#123;</span><br><span class="line">  <span class="attr">_idcard</span>: &#123; <span class="comment">// 数据属性</span></span><br><span class="line">    <span class="attr">value</span>: <span class="number">123456789</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">idcard</span>: &#123; <span class="comment">// 访问器属性</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_idcard</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = newValue - <span class="variable language_">this</span>.<span class="property">_idcard</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_idcard</span> = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="读取属性的特性">读取属性的特性</h2>
<p><code>ECMAScript 5</code> 的 <code>Object.getOwnPropertyDescriptor()</code> 方法，可以取得给定属性的描述符。参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对，如果是访问器属性，这个对象的属性有： <code>configurable</code> 、 <code>enumerable</code> 、 <code>get</code> 和 <code>set</code> 。如果是数据属性，这个对象的属性有： <code>configurable</code> 、 <code>enumerable</code> 、 <code>writable</code> 和 <code>value</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取属性的特性</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person, &#123;</span><br><span class="line">  <span class="attr">_idcard</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123456789</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">idcard</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_idcard</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = newValue - <span class="variable language_">this</span>.<span class="property">_idcard</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_idcard</span> = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor1 = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;_idcard&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor1) <span class="comment">// &#123;value: 123456789, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor2 = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;idcard&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor2) <span class="comment">// &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125;</span></span><br></pre></td></tr></table></figure>
<h1>创建对象</h1>
<p><code>Object</code> 构造函数和对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>ECMAScript 中无法创建类，开发人员发明了一种函数，用函数来封装以特定的接口创建对象的细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式创建对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> object = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  object.<span class="property">name</span> = name</span><br><span class="line">  object.<span class="property">age</span> = age</span><br><span class="line">  object.<span class="property">gender</span> = gender</span><br><span class="line">  object.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zs = <span class="title function_">createPerson</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs) <span class="comment">// &#123; name: &#x27;zs&#x27;, age: 18, gender: &#x27;男&#x27;, sayName: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="keyword">const</span> ls = <span class="title function_">createPerson</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ls) <span class="comment">// &#123; name: &#x27;ls&#x27;, age: 18, gender: &#x27;女&#x27;, sayName: [Function (anonymous)] &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数模式">构造函数模式</h2>
<p>构造函数创建特定类型的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数创建对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs) <span class="comment">// &#123; name: &#x27;zs&#x27;, age: 18, gender: &#x27;男&#x27;, sayName: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="keyword">const</span> ls = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ls) <span class="comment">// &#123; name: &#x27;ls&#x27;, age: 18, gender: &#x27;女&#x27;, sayName: [Function (anonymous)] &#125;</span></span><br></pre></td></tr></table></figure>
<p>与工厂模式不同的是：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋值给了 <code>this</code> 对象</li>
<li>没有 <code>return</code> 语句</li>
</ul>
<blockquote>
<p>构造函数的函数名的首字母最好大写，以区分其他函数，构造函数也是函数，只不过可以用来创建对象。</p>
</blockquote>
<p>创建新实例必须使用 <code>new</code> 操作符。有以下四个步骤：</p>
<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象(因此 this 就指向看这个新对象)</li>
<li>执行构造函数中的代码(为新对象添加属性)</li>
<li>返回新对象</li>
</ul>
<p><code>person1</code> 和 <code>person2</code> 都分别保存着 <code>Person</code> 的不同实例。这两个对象都拥有 <code>constructor(构造函数)</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">constructor</span> = <span class="title class_">Person</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">constructor</span> = <span class="title class_">Person</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数当作函数">构造函数当作函数</h3>
<p>构造函数和其他函数的不同在于调用的方式。构造函数也是函数的一种，不存在定义构造函数的特殊语法。任何函数只要通过 <code>new</code> 操作符来调用，那么她就可以作为沟站是；而任何函数，如果不通过 <code>new</code> 操作符来调用，那他跟普通函数没什么区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">person.<span class="title function_">sayName</span>() <span class="comment">// zs</span></span><br><span class="line"><span class="comment">// 当作普通函数调用</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>) <span class="comment">// 在浏览器添加到 window 对象</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>() <span class="comment">// ls</span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">const</span> object = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">sayName</span>.<span class="title function_">call</span>(object, <span class="string">&#x27;ww&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">object.<span class="title function_">sayName</span>() <span class="comment">// ww</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数的问题">构造函数的问题</h3>
<p>构造函数模式的问题在于：每个方法都要在实例上重新创建。在 <code>ECMAScript</code> 中的函数的对象，因此每定义一个函数，也就是实例化一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑上构造函数的定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;console.log(this.name)&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种创建函数，会导致不同的作用域链和标识符解析，但创建 <code>Function</code> 新实例的机制仍然是先天的，不同的实例上的同名函数是不相等的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 证明不同实例上的同名函数是不相等的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person.<span class="property">sayName</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>可以通过将函数定义转移到构造函数外来解决这个问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将函数定义转移到构造函数解决重复创建函数的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; <span class="comment">// 函数提升</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">sayName</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zs = <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs) <span class="comment">// &#123; name: &#x27;zs&#x27;, age: 18, gender: &#x27;男&#x27;, sayName: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="keyword">const</span> ls = <span class="title class_">Person</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ls) <span class="comment">// &#123; name: &#x27;ls&#x27;, age: 18, gender: &#x27;女&#x27;, sayName: [Function (anonymous)] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs.<span class="property">sayName</span> == ls.<span class="property">sayName</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这样做解决了重复创建函数的问题，但是又带来了一个新问题：在全局作用域中定义的函数只能被某个对象调用，这样让全局作用域很尴尬，而且更严重的问题是：如果需要定义很多方法，那么需要在全局作用域定义很多全局函数，这样引用类型没有封装性了。这个问题需要通过原型链模式解决。</p>
<h2 id="原型链模式">原型链模式</h2>
<p>我们创建的每一个函数都有 <code>peototype(原型)</code> 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。简单的说： <code>peototype</code> 通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处在于让所有对象共享它的属性和方法。不需要再构造方法总定义对象的实例信息，而将信息直接添加到原型对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型模式的使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// zs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person2.<span class="title function_">sayName</span>() <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<h3 id="理解原型对象">理解原型对象</h3>
<p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 <code>peototype</code> 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 <code>constructor(构造函数)</code> 属性，这个属性指向 <code>peototype</code> 属性所在函数的指针。对于前一个例子， <code>Person.peototype</code> ， <code>constructor</code> 指向 <code>Person</code> 。而通过这个构造函数，我们还可以继续为原型对象添加属性和方法。</p>
<p>创造自定义的构造函数之后，其原型对象默认只会取得 <code>constructor</code> 属性；至于其他方法，则都是从 Object 继承而来。调用构造函数创建一个新实例后，该实例内部包含一个指针(内部属性)，指向构造函数的原型对象。在脚本中没有标准的方式访问 <code>[[Prototype]]</code><br>
，在各大浏览器中在每个对象上都支持 <code>__proto__</code>；在其他实现中，这个属性对脚本是完全不可见的。需要明确的是：连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen-lihao/picgo_images/images/%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="实例与原型之间的关系图，图片来自于书本"></p>
<p>从图中可以看出<strong>实例</strong>和<strong>构造函数</strong>没有直接的关系，虽然两个实例都不包含属性和方法，但我们可以调用 <code>person1.sayName()</code> 。这个是通过查找对象属性的过程来实现的。</p>
<p>虽然在所有实现中都无法访问到 <code>[[Prototype]]</code> ， 但可以通过 <code>isPrototypeOf()</code> 方法来确定对象之间是否存在这种关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断实例和对象是否存在关系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1)) <span class="comment">// true 表示存在关系，false 表示不存在关系</span></span><br></pre></td></tr></table></figure>
<p>调用原型对象的 <code>isPrototypeOf()</code> 方法测试 <code>person1</code>  。因为它们内部都有一个指向 <code>Person.prototype</code> 的指针，因此都返回了 <code>true</code> 。</p>
<p>在 <code>ECMAScript 5</code> 中有 <code>Object.getPrototypeOf()</code> 方法能够返回 <code>[[Prototype]]</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Object.getPrototypeOf() 获取原型对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1).<span class="property">name</span>) <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>Object.getPrototypeOf()</code> 可以方便的获取一个对象的原型，这在利用原型实现继承的情况下是非常重要的。</p>
<blockquote>
<p>当代码读取某个对象的属性时，会执行一次搜索，目标是给定名字的属性。搜索先从对象实例本身开始，通过实例中找到了给定名称的属性，则返回属性值，如果没有找到，则继续搜索实例的原型对象，在原型对象中查找具有给定名称的属性，在原型中找到则返回原型中该属性名称的值。</p>
</blockquote>
<blockquote>
<p>原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 证明搜索属性的存在</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;ww&#x27;</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// ww 来着实例的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person2.<span class="title function_">sayName</span>() <span class="comment">// zs  来着原型的属性</span></span><br></pre></td></tr></table></figure>
<p>上述例子造成一个问题，当我们设置了与原型相同属性名的属性，会阻止访问原型中的属性，就算将实例的中的属性赋值为 <code>null</code> 仍然会阻止访问原型中的属性，如果我们仍然需要访问原型中的属性，我们可以通过 <code>delete</code> 操作符删除实例中的属性，再访问原型中的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现实例属性已存在访问原型的属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;ww&#x27;</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// ww 来着实例的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person2.<span class="title function_">sayName</span>() <span class="comment">// zs  来着原型的属性</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="literal">null</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// null 实例中的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// zs 原型中的属性</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>hasOwnProperty()</code> 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中，才会返回 <code>true</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;ww&#x27;</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// ww 来着实例的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">person2.<span class="title function_">sayName</span>() <span class="comment">// zs  来着原型的属性</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">name</span> = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// null 实例中的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// zs 原型中的属性</span></span><br></pre></td></tr></table></figure>
<p>下图可以便于大家理解(由于自己敲了一遍验证，因此与原文不太一样了，原理是相同的)：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen-lihao/picgo_images/images/%E5%B1%9E%E6%80%A7%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E8%BF%98%E6%98%AF%E5%8E%9F%E5%9E%8B.jpg" alt="属性来自于实例还是原型，图片来自于书本"></p>
<blockquote>
<p><code>Object.getOwnPropertyDescriptor()</code> 方法只能用于实例属性，要取得原型的描述符，必须直接在原型对象调用 <code>Object.getOwnPropertyDescriptor()</code> 方法。</p>
</blockquote>
<h3 id="原型与-in-操作符">原型与 in 操作符</h3>
<p>使用 <code>in</code> 操作符的两种方式：单独使用和在 <code>for-in</code> 循环中使用。 单独使用 <code>in</code> 操作符会在通过对象能够访问给定属性是返回 <code>true</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;ww&#x27;</span></span><br><span class="line">person1.<span class="title function_">sayName</span>() <span class="comment">// ww 来着实例的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br><span class="line">person2.<span class="title function_">sayName</span>() <span class="comment">// zs  来着原型的属性</span></span><br></pre></td></tr></table></figure>
<p>同时使用 hasOwnProperty() 和 in 操作符可以判断属性存在于对象还是原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断属性存在于对象还是原型的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; object 需要判断的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; name 需要判断的属性名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypeProperty</span>(<span class="params">object, name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> object.<span class="title function_">hasOwnProperty</span>(name) &amp;&amp; name <span class="keyword">in</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 for-in 循环时，返回的是所有能够通过对象访问的，可枚举的(enumerated)属性，包括存在于对象实例和原型中的属性。屏蔽了原型中不可枚举的属性(**[[Enumerable]]**为 <code>false</code> 的属性)的实例属性也会在 for-in 循环中返回。开发人员自己定义的属性属于可枚举属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-in 枚举属性</span></span><br><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;I am object&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(prop); <span class="comment">// name, toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中， <code>object</code> 的 <code>toString()</code> 方法屏蔽了原型中不可枚举的 <code>toString()</code> 方法。除了  <code>toString()</code> 方法， <code>hasOwnProperty()</code> 、 <code>propertyIsEnumerable()</code> 、 <code>toLocalString()</code> 和 <code>valueOf()</code> 方法也是不可枚举的。</p>
<p><code>ECMAScript 5</code> 也将 <code>constructor</code> 和 <code>prototype</code> 属性的 <code>[[Enumerable]]</code> 特性特性设置为 <code>false</code> ，但不是所有的浏览器都是这样实现的。</p>
<p>要取得对象上所有可枚举的实例属性，可以使用 <code>ECMAScript 5</code> 的 <code>Object.keys()</code> 方法，参数: 需要枚举属性的对象， 返回：一个包含所有可枚举属性的字符串数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Object.keys() 获取属性名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> perKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(perKeys) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> perProKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(perProKeys) <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;, &#x27;sayName&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ls = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">ls.<span class="property">name</span> = <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">ls.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> lsKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(ls) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lsKeys) <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>获取所有的实例属性(包括不可枚举属性)，可以使用 <code>Object.getOwnPropertyNmaes()</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allPerKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allPerKeys) <span class="comment">// [ &#x27;length&#x27;, &#x27;name&#x27;, &#x27;arguments&#x27;, &#x27;caller&#x27;, &#x27;prototype&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allPerProKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allPerProKeys) <span class="comment">// [ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;, &#x27;sayName&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ls = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">ls.<span class="property">name</span> = <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">ls.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allLsProKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(ls)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allLsProKeys) <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h3 id="更简单的原型语法">更简单的原型语法</h3>
<p>为了简化减少输入和更好的封装原型变量，可以使用字面量的方式重写整个原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量的方式重写整个原型对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法中虽然以字面量的方式创建了新对象，但是 <code>constructor</code> 属性不再指向 <code>Person</code> 。当我们每创建一个函数，就会同时创建它的 <code>prototype</code> 对象，并且 <code>prototype</code> 对象的 <code>constructor</code> 属性也会自动指向这个<code>函数(Person)</code>。使用字面量的形式等同于重写了默认的 <code>prototype</code> 对象，因此原型对象的 <code>constructor</code> 属性指向了 <code>Object的构造函数</code> ， 不指向 <code>Person</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量形式原型的 constructor 指向问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs <span class="keyword">instanceof</span> <span class="title class_">Person</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs.<span class="property"><span class="keyword">prototype</span></span> == <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs.<span class="property"><span class="keyword">prototype</span></span> == <span class="title class_">Person</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>constructor</code> 属性的值非常重要，不可缺失，可以使用 <code>Object.defineProperty()</code> 设置 <code>constructor</code> 属性的指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恢复字面量方式原型的 constructor 属性指向问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要在使用字面量时直接指定原型的 <code>constructor</code> 属性的指向，这样会造成 <code>constructor</code> 属性可枚举(<strong>[[Enumerable]]</strong> 的值为 <code>true</code> )</p>
</blockquote>
<h3 id="原型的动态性">原型的动态性</h3>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所作的任何修改都能够立即从实例上反映。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 证明原型的动态性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">person.<span class="title function_">sayHi</span>() <span class="comment">// hi!</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写已经有实例的对象的原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">sayHi</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>实例中的指针仅指向原型，而不指向构造函数。重写原型等于切断已有实例和原型之间的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen-lihao/picgo_images/images/%E9%87%8D%E5%86%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.jpg" alt="重写原型对象示意图"></p>
</blockquote>
<h3 id="原生对象的原型">原生对象的原型</h3>
<p><strong>原型模式</strong>的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有的原生引用类型(<code>Object</code> 、 <code>Array</code> 、 <code>String</code> 等)都在其构造函数的原型上定义了方法。</p>
<p>通过原生对象的原型，可以获得所有默认方法的引用，并且可以定义新方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义原生对象的方法</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addLogo</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 这里不可以使用箭头函数，this的指向会有问题</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;MyString:&#x27;</span> + <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;you are best!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="title function_">addLogo</span>()) <span class="comment">// MyString:you are best!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管可以对原生对象增加新的方法，但是不推荐这样做，因这么做可能会导致明明冲突。并且有可能会意外的重写原生方法。</p>
</blockquote>
<h3 id="原型对像的问题">原型对像的问题</h3>
<p>原型对象的问题在于：它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下将取得相同的属性值。 原型模式最大的问题是由其共享的本性导致的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Person</span>, <span class="comment">// 这里constructor可枚举</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>],</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">p1.<span class="property">friend</span>.<span class="title function_">push</span>(<span class="string">&quot;yxl&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">friend</span>) <span class="comment">// [ &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;yxl&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">friend</span>) <span class="comment">// [ &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;yxl&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">friend</span> == p2.<span class="property">friend</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的例子造成了 <code>p1</code> 和 <code>p2</code> 共有 <code>friend</code> 的情况。而真实情况下应该是 <code>p1</code> 有自己的朋友， <code>p2</code> 也有自己的朋友。这就是单独原型模式所带来的问题。</p>
<h2 id="组合使用构造函数模式和原型模式">组合使用构造函数模式和原型模式</h2>
<p>创建自定义类型的常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。最终的结果就是：每个实例都会有这就的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。这两种混成模式还支持向构造函数传递参数，结合了两种模式的长处。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数模式和原型模式创建对象实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Person</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> atm = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line"></span><br><span class="line">zs.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;yxl&#x27;</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs.<span class="property">friends</span>) <span class="comment">// [ &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;yxl&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(atm.<span class="property">friends</span>) <span class="comment">// [ &#x27;ls&#x27;, &#x27;ww&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs.<span class="property">friends</span> == atm.<span class="property">friends</span>) <span class="comment">// false 不同的实例的属性具有不同的指向</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zs.<span class="property">sayName</span> == atm.<span class="property">sayName</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这种构造函数和原型混成的模式，是目前在 <code>ECMAScript</code> 中最广泛使用、认同度最高的一种创建自定义类型的方法。</p>
<h2 id="动态原型模式">动态原型模式</h2>
<p>其他有面向对象语言经验的开发人员看到独立的构造函数和原型时，会感到很疑惑。动态原型模式正是致力于解决这个问题的方案，它把所有的信息都封装在构造函数里面，通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点。可以检查某个应该存在的方法是否有效来决定是否需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态原型模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">zs.<span class="title function_">sayName</span>() <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断所有实例与新原型之间的联想(原型的地址变化)。</p>
</blockquote>
<h2 id="寄生构造函数模式">寄生构造函数模式</h2>
<p>在前面几种模式的不适合的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的思想是：创建应该函数，函数的作用是封装对象的代码，再返回新建的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生构造函数模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> object = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  object.<span class="property">name</span> = name</span><br><span class="line">  object.<span class="property">age</span> = age</span><br><span class="line">  object.<span class="property">gender</span> = gender</span><br><span class="line">  object.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 不可以使用箭头函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">zs.<span class="title function_">sayName</span>() <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<p>这个模式可以在特殊情况下用来为对象创建构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建特殊在数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建数组</span></span><br><span class="line">  <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line">  <span class="comment">// 添加元素</span></span><br><span class="line">  values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  values.<span class="property">toPipedString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names.<span class="title function_">toPipedString</span>()) <span class="comment">// zs|ls|ww</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于寄生构造函数模式的注意点： 返回对象与构造函数或者与构造函数的原型属性之间没有关系。因此不能使用 <code>instanceof</code> 操作符来确定对象类型。</p>
</blockquote>
<h2 id="稳妥构造函数模式">稳妥构造函数模式</h2>
<p>稳妥对象是指没有公共属性，而且其方法也不引用 this 的对象。稳妥构造函数模式和寄生构造函数类似，但是有两个不同点：</p>
<ul>
<li>新创建对象的实例方法不引用 <code>this</code></li>
<li>不使用 <code>new</code> 操作符调用构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稳妥构造函数模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">const</span> object = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="comment">// 定义私有变量和函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  object.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>) </span><br><span class="line">p1.<span class="title function_">sayName</span>() <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有关系，因此 <code>instanceof</code> 操作符对这种对象也没用意义</p>
</blockquote>
<h1>继承</h1>
<p><strong>继承</strong>是面向对象语言的一个最为人津津乐道的概念。许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在 <code>ECMAScript</code> 种无法实现接口继承。 <code>ECMAScript</code> 只支持实现继承，而且实现继承主要是依靠原型链来实现的。</p>
<h2 id="原型链">原型链</h2>
<p><code>ECMAScript</code> 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p><strong>构造函数、原型和实例的关系：</strong> 每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p>如果我们让原型对象等于另一个类型的实例，结果会怎么样？此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上诉关系依然成立，如此层层递进，就构成了实例与原型的链条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型链体验</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中定义了两个类型： <code>SuperType</code> 和 <code>SubType</code> 。每个类型分别有一个属性和一个方法。主要的区别在于 <code>SubType</code> 继承了 <code>SuperType</code> ， 而继承是通过创建 <code>SuperType</code> 的实例，并将该实例给 <code>SubType.prototype</code> 实现的。实现的本质是重写原型对象，用一个新类型的实例替代，也就是原来存在于 <code>SuperType</code> 的实例中的所有方法和属性也存在与 <code>SubType.prototype</code> 中。在确立了继承关系之后，我们给 <code>SubType.prototype</code> 添加了一个方法，主要就在继承了 <code>SuperType</code> 的属性和方法的基础上又添加了一个新方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen-lihao/picgo_images/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A1%88%E4%BE%8B.jpg" alt="原型链案例图"></p>
<p>对于上面代码，调用 <code>instance.getSuperValue()</code> 的三个步骤：</p>
<ul>
<li>搜索实例</li>
<li>搜索 <code>SubType.prototype</code></li>
<li>搜索 <code>SuperType.prototype</code> (在这一步找到了方法)</li>
</ul>
<h3 id="别忘记默认的原型">别忘记默认的原型</h3>
<p>所有的引用类型都默认继承了 <code>Object</code> ， 而这个继承也是通过原型链实现的。所有函数的默认原型都是 <code>Object</code> 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code> 。 这也是所有自定义类型都会继承 <code>toString()</code> 、 <code>valueOf()</code> 等默认方法的根本原因。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen-lihao/picgo_images/images/%E5%AE%8C%E6%95%B4%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A1%88%E4%BE%8B.jpg" alt="完整原型链案例"></p>
<h3 id="确定原型和实例的关系">确定原型和实例的关系</h3>
<p>有两种方式：</p>
<ul>
<li>第一种使用 <code>instanceof</code> 操作符，这个操作符能够测试实例与原型链中出现过的构造函数。<strong>结果：</strong> 如果出现了就会返回 <code>true</code> 否在会返回 <code>false</code> 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 操作符确定实例是否由构造方法派生</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SuperType</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SubType</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="comment">// true 构造函数的原型的 constructor 指向 Function</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>isPrototypeOf(object)</code> 方法。只要是原型链中出现过的原型，都是该原型链所派生的实例的原型。<strong>参数：</strong> <code>object</code> : 需要检测的对象， <strong>返回值：</strong> 如果出现了就会返回 <code>true</code> 否在会返回 <code>false</code> 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isPrototypeOf(object) 方法确定实例是否由构造函数派生出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="谨慎地定义方法">谨慎地定义方法</h3>
<p>子类型有时候需要重写超类型的某个方法，或者需要添加超类型中不存在的某个方法。但是不管是哪种情况，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写或者添加超类型的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写超类型中的方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，SubType 重写了 <code>SuperType</code> 中的 <code>getSuperValue()</code> 方法，这样根据原型的搜索原则，会<strong>屏蔽</strong>掉 <code>SuperType</code> 的 <code>getSuperValue()</code> 方法。</p>
<blockquote>
<p>注意： 一定要在 <code>SuperType</code> 的实例替换原型之后，再定义两个方法，先定义的话会被 <code>SuperType</code> 的实例<strong>覆盖</strong>掉。使用字面量的方式也是产生类似的效果，会<strong>破坏</strong>原型链</p>
</blockquote>
<h3 id="原型链的问题">原型链的问题</h3>
<p>原型链最主要的问题来自包含引用类型的值的原型。</p>
<ul>
<li>引用型值的原型属性会被所有实例共享，在通过原型来继承时，原型实际上会变成另一个类型的实例，这样原先的实例属性就变成了现在的原型属性了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型链的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了 SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line">instance1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;atm&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">friends</span>) <span class="comment">// [ &#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;atm&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title function_">friends</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">names</span>) <span class="comment">// [ &#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;atm&#x27; ] 共享了 friends 属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在创建子类型实例时，不能在不影响所有对象实例的情况下向超类型的构造函数传递参数。</li>
</ul>
<p>实际使用中<strong>很少单独使用</strong>原型链。</p>
<h2 id="借用构造函数">借用构造函数</h2>
<p><strong>借用构造函数：</strong> 在子类型构造函数的内部调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借用构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 继承 SuperType</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line">instance1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;atm&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">friends</span>) <span class="comment">// [ &#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;atm&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">friends</span>) <span class="comment">// [ &#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>call()</code> 方法(或 <code>apply()</code> 方法也可以)调用超类型的构造函数，这样会在新的 SubType 对象上执行初始化代码，因此每个实例都会拥有自己的 <code>friends</code> 属性。</p>
<h3 id="传递参数-2">传递参数</h3>
<p>构造函数可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数 传参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 继承 SuperType 并传递参数</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>) <span class="comment">// zs</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<h3 id="借用构造函数的问题">借用构造函数的问题</h3>
<p>借用构造函数的问题</p>
<ul>
<li>方法都在构造函数中定义，<strong>函数的复用</strong>就没有意义的</li>
<li>超类型的原型中定义的方法，对子类而已是<strong>不可见</strong>的，所有类型都只能使用构造函数模式。</li>
</ul>
<h2 id="组合继承">组合继承</h2>
<p>组合继承(经典继承)是将<strong>原型链</strong>和<strong>借用构造函数</strong>的技术组合到一块。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样保证了原型上定义方法实现了服用，有保证每个实例都有它自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;atm&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">instance1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;zsf&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">friends</span>) <span class="comment">// [ &#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;zsf&#x27; ]</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>() <span class="comment">// atm</span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>() <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;gx&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">friends</span>) <span class="comment">// [ &#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27; ]</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>() <span class="comment">// gx</span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>() <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<h2 id="原型式继承">原型式继承</h2>
<p>原型式继承并没有使用严格意义上的构造函数，他的想法是借助原型可以基于<strong>已有对象创建新对象</strong>，并且不必因此创建自定义类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="title function_">object</span>(person)</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&#x27;atm&#x27;</span></span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;zsf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yetAnotherPerson = <span class="title function_">object</span>(person)</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&#x27;gx&#x27;</span></span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;yg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>) <span class="comment">// [ &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;zsf&#x27;, &#x27;yg&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>上述代码实际上相当于又创建了 <code>person</code> 对象的两个副本</p>
<p><code>ECMAScript 5</code> 通过新增 <code>Object.create()</code> 方法规范化了原型式继承，这个方法接收两个参数：</p>
<ul>
<li>用作新对象原型的对象</li>
<li>新对象定义额外属性的对象(可选)</li>
</ul>
<p>传入一个参数时， <code>Object.create()</code> 与上述 object() 方法的行为相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create() 方法的使用</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&#x27;atm&#x27;</span></span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;zsf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&#x27;gx&#x27;</span></span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;yg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>) <span class="comment">// [ &#x27;ls&#x27;, &#x27;ww&#x27;, &#x27;zsf&#x27;, &#x27;yg&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p><code>Object.create()</code> 的第二个参数格式与 <code>Object.defineProperties()</code> 方法的第二个参数格式相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create() 传递第二个参数</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;atm&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherPerson.<span class="property">name</span>) <span class="comment">// atm</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生式继承">寄生式继承</h2>
<p>寄生式继承是创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作拥有返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title function_">object</span>(original)</span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="title function_">createAnother</span>(person)</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，这一点与构造函数模式类似。</p>
</blockquote>
<h2 id="寄生组合式继承">寄生组合式继承</h2>
<p>组合式继承的问题在于：会调用两次超类型构造函数。</p>
<ul>
<li>在创建子类型原型的时候</li>
<li>子类型构造函数内部</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合式继承的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>() <span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寄生组合式继承：通过借用构造函数来继承属性，通过原型链混成形式来继承方法。</p>
<p>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的是超类型原型的一个副本。本质上，就算使用寄生式继承来继承超类型的原型，然后将结果指定给子类型的原型</p>
<p><code>inheritPrototype()</code> 方法接收两个参数：</p>
<ul>
<li>子类型的构造函数</li>
<li>超类型的构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生组合式继承的基本模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 创建超类型的副本</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = subType <span class="comment">// 为创建的副本添加 constructor 属性，弥补因重写原型而失去默认的 constructor 属性</span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = prototype <span class="comment">// 将新创建的对象赋值给子类型的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1504784759@qq.com">Hao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://clh.lovehao.ren/2022/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%BA%94)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">https://clh.lovehao.ren/2022/03/28/JavaScript学习之路(五)面向对象程序设计/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://clh.lovehao.ren" target="_blank">陈励昊的博客空间</a>！ 如果博客中的内容侵犯了您的版权，请与作者联系以将其删除。 非常感谢 ！(本文是根据JavaScript高级程序设计（第3版）总结的笔记！)</span></span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/article5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/30/%E6%AF%8F%E6%97%A5%E7%BC%96%E7%A8%8B-20220330/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qnyoss.lovehao.ren/article1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">每日编程(20220330)</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-20220326/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法之路(20220326)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/17/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%B8%80)%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="JavaScript学习之路 (一) 基本数据类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-17</div><div class="title">JavaScript学习之路 (一) 基本数据类型</div></div></a></div><div><a href="/2022/03/18/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%B8%89)%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98/" title="JavaScript学习之路(三)变量、作用域和内存"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qnyoss.lovehao.ren/article3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">JavaScript学习之路(三)变量、作用域和内存</div></div></a></div><div><a href="/2022/03/18/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%BA%8C)%E6%93%8D%E4%BD%9C%E7%AC%A6/" title="JavaScript学习之路 (二) 操作符"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">JavaScript学习之路 (二) 操作符</div></div></a></div><div><a href="/2022/04/01/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E5%85%AD)%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="JavaScript学习之路(六) 函数表达式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="title">JavaScript学习之路(六) 函数表达式</div></div></a></div><div><a href="/2022/03/18/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E5%9B%9B)%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" title="JavaScript学习之路 (四) 引用类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qnyoss.lovehao.ren/article1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">JavaScript学习之路 (四) 引用类型</div></div></a></div><div><a href="/2022/04/08/%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%84%E7%90%86/" title="嵌套数组的扁平化处理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">嵌套数组的扁平化处理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hao</div><div class="author-info__description">Curious about the world of code!</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chen-lihao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chen-lihao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1504784759@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">属性类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">访问器属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">读取属性的特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BD%93%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造函数当作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">原型链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">理解原型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E-in-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.3.2.</span> <span class="toc-text">原型与 in 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E5%8E%9F%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">更简单的原型语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">原型的动态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.3.5.</span> <span class="toc-text">原生对象的原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E5%83%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.6.</span> <span class="toc-text">原型对像的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">寄生构造函数模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%B3%E5%A6%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.1.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E5%BF%98%E8%AE%B0%E9%BB%98%E8%AE%A4%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">别忘记默认的原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">确定原型和实例的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%A8%E6%85%8E%E5%9C%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">谨慎地定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">原型链的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">借用构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">借用构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.6.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/28/webpack%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="webpack相关知识"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack相关知识"/></a><div class="content"><a class="title" href="/2023/06/28/webpack%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="webpack相关知识">webpack相关知识</a><time datetime="2023-06-28T09:31:50.000Z" title="发表于 2023-06-28 17:31:50">2023-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/24/openssl%E7%9A%84%E4%BD%BF%E7%94%A8/" title="SSL/TSL及openssl的使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSL/TSL及openssl的使用"/></a><div class="content"><a class="title" href="/2023/06/24/openssl%E7%9A%84%E4%BD%BF%E7%94%A8/" title="SSL/TSL及openssl的使用">SSL/TSL及openssl的使用</a><time datetime="2023-06-24T07:33:34.000Z" title="发表于 2023-06-24 15:33:34">2023-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/30/MQ%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/" title="MQ服务异步通信"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qnyoss.lovehao.ren/article1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQ服务异步通信"/></a><div class="content"><a class="title" href="/2023/01/30/MQ%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/" title="MQ服务异步通信">MQ服务异步通信</a><time datetime="2023-01-30T08:54:39.000Z" title="发表于 2023-01-30 16:54:39">2023-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/28/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式事务"/></a><div class="content"><a class="title" href="/2023/01/28/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务">分布式事务</a><time datetime="2023-01-28T11:44:52.000Z" title="发表于 2023-01-28 19:44:52">2023-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/28/JMeter%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" title="JMeter安装教程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/article5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JMeter安装教程"/></a><div class="content"><a class="title" href="/2023/01/28/JMeter%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" title="JMeter安装教程">JMeter安装教程</a><time datetime="2023-01-28T02:59:17.000Z" title="发表于 2023-01-28 10:59:17">2023-01-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/article5.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Hao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>